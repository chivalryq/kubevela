apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: cloneset-service
  namespace: vela-system
  annotations:
    definition.oam.dev/description: "Describes long-running, scalable, containerized services that have a stable network endpoint to receive external network traffic from customers.
    If workload type is skipped for any service defined in Appfile, it will be defaulted to `webservice` type."
spec:
  workload:
    definition:
      apiVersion: apps.kruise.io/v1alpha1
      kind: CloneSet
  schematic:
    cue:
      template: |
        output: {
        	apiVersion: "apps.kruise.io/v1alpha1"
        	kind:       "CloneSet"
        	metadata: labels: {
        		"app.oam.dev/component": context.name
        	}
        	spec: {
        		if parameter["replicas"] != _|_ {
        			replicas: parameter.replicas
        		}
        		selector: matchLabels: {
        			"app.oam.dev/component": context.name
        		}

        		template: {
        			metadata: labels: {
        				"app.oam.dev/component": context.name
        			}

        			spec: {
        				containers: [{
        					name:  context.name
        					image: parameter.image

        					if parameter.cmd != _|_ {
        						command: parameter.cmd
        					}
        					if parameter.args != _|_ {
        						args: parameter.args
        					}
        					if parameter.env != _|_ {
        						env: parameter.env
        					}

        					if context.config != _|_ {
        						env: context.config
        					}

        					ports: [{
        						containerPort: parameter.port
        					}]

        					resources: {
        						limits:
        							cpu: parameter.cpu
        						memory: parameter.memory
        						requests:
        							cpu: parameter.cpu
        						memory: parameter.memory
        					}

        					if parameter.readinessProbe != _|_ {
        						readinessProbe: {
        							initialDelaySeconds: parameter.readinessProbe.waitServiceStartUpSeconds
        							periodSeconds:       parameter.readinessProbe.periodSeconds
        							exec: command: parameter.readinessProbe.cmd
        						}
        					}
        					if parameter.livenessProbe != _|_ {
        						livenessProbe: {
        							initialDelaySeconds: parameter.livenessProbe.waitServiceStartUpSeconds
        							periodSeconds:       parameter.livenessProbe.periodSeconds
        							exec: command: parameter.livenessProbe.cmd
        						}
        					}
        					if parameter.volumes != _|_ {
        						volumeMounts: [ for v in parameter.volumes {
        							mountPath: v.mountPath
        							name:      v.name
        							if v.readOnly != _|_ {
        								readOnly: v.readOnly
        							}
        							if v.subPath != _|_ {
        								subPath: v.subPath
        							}
        						}]
        					}
        					lifecycle: {
        						if parameter.postStart != _|_ {
        							postStart: exec: command: parameter.postStart
        						}
        						if parameter.preStop != _|_ {
        							preStop: exec: command: parameter.preStop
        						}
        					}

        				}]
        			if parameter.volumes != _|_ {
        				volumes: [ for v in parameter.volumes {
        					name: v.name
        					if v.type == "pvc" {
        						persistentVolumeClaim: {
        							claimName: v.claimName
        						}
        					}
        					if v.type == "configMap" {
        						configMap: {
        							defaultMode: v.defaultMode
        							name:        v.cmName
        							if v.items != _|_ {
        								items: v.items
        							}
        						}
        					}
        					if v.type == "secret" {
        						secret: {
        							defaultMode: v.defaultMode
        							secretName:  v.secretName
        							if v.items != _|_ {
        								items: v.items
        							}
        						}
        					}
        					if v.type == "emptyDir" {
        						emptyDir: {
        							if v.sizeLimit != _|_ {
        								sizeLimit: v.sizeLimit
        							}
        							medium: v.medium
        						}
        					}
        				}]
        			}
        			if parameter.hostAliases != _|_ {
        				hostAliases: parameter.hostAliases
        			}
        		}
        		}
        		if parameter.updateStrategyType != _|_ {
        			updateStrategy: {
        				type: parameter.updateStrategyType
        			}
        		}
        	}
        }

        parameter: {
        	// +usage=Which image would you like to use for your service
        	// +short=i
        	image: string

        	// +usage=Number of CPU units for the service, like `0.5` (0.5 CPU core), `1` (1 CPU core)
        	cpu: string

        	// +usage=Specify the amount of memory to limit
        	memory: *"2048Mi" | =~"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$"

        	// +usage=Commands to run in the container
        	cmd?: [...string]

        	// +usage=Arguments to the command.
        	args?: [...string]

        	// +usage=postStart commands will be called immediately after a container is created.
        	postStart?: [...string]

        	// +usage=PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The reason for termination is passed to the handler. The Pod's termination grace period countdown begins before the PreStop hooked is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        	preStop?: [...string]

        	// +usage=Which port do you want customer traffic sent to
        	// +short=p
        	port: *80 | int

        	// +usage=Define arguments by using environment variables
        	env?: [...#ENV]

        	// +usage=Cloneset updateStrategy, candidates are `ReCreate`/`InPlaceIfPossible`/`InPlaceOnly`
        	updateStrategyType?: string

        	// +usage=Number of pods in the cloneset
        	replicas?: int

        	// +usage=Volumes to be mount
        	volumes?: [...#Volume]

        	// +usage=HostAliases is a list of hosts and IPs that will be write into the pod's hosts file
        	hostAliases?: [...{
        		hostnames: [...string]
        		ip: string
        	}]

        }

        #ENV: {
        	// +usage=Environment variable name
        	name: string
        	// +usage=The key of the secret to select from. Must be a valid secret key
        	value?: string
        	// +usage=The value of the environment variable
        	valueFrom?: {
        		// +usage=Selects a key of a secret in the pod's namespace
        		secretKeyRef?: {
        			// +usage=The name of the secret in the pod's namespace to select from
        			name: string
        			// +usage=The key of the secret to select from. Must be a valid secret key
        			key: string
        		}
        		// +usage=Select a pod filed as env source
        		fieldRef?: {
        			// +usage=Version of the schema the fieldPath is written in terms of, defaults to "v1".
        			apiVersion: *"v1" | string
        			// Path of the field to select
        			fieldPath: string
        		}
        	}

        	readinessProbe?: #ProbeAction
        	livenessProbe?:  #ProbeAction
        }

        #ProbeAction: {
        	// +usage=Number of seconds after the container has started before liveness probes are initiated
        	waitServiceStartUpSeconds: *20 | int

        	// +usage=How often (in seconds) to perform the probe
        	periodSeconds: *10 | int

        	// +usage=Command is the command line to execute inside the container
        	cmd: [...string]
        }

        #Volume: {
        	name:      string
        	mountPath: string
        	readOnly?: bool
        	subPath?:  string
        	type:      "pvc" | "configMap" | "secret" | "emptyDir"
        	if type == "pvc" {
        		claimName: string
        	}
        	if type == "configMap" {
        		defaultMode: *420 | int
        		cmName:      string
        		items?: [...{
        			key:  string
        			path: string
        			mode: *511 | int
        		}]
        	}
        	if type == "secret" {
        		defaultMode: *420 | int
        		secretName:  string
        		items?: [...{
        			key:  string
        			path: string
        			mode: *511 | int
        		}]
        	}
        	if type == "emptyDir" {
        		medium:     *"" | "Memory"
        		sizeLimit?: string
        	}
        }